/*
 * SPDX-License-Identifier: GPL-2.0-only
 * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
 */

#ifndef _ECPRI_DMA_ETH_H_
#define _ECPRI_DMA_ETH_H_

#include "ecpri_dma.h"

typedef u32 ecpri_dma_eth_conn_hdl_t;

/**
 * struct ecpri_dma_eth_rx_comp_cb - ecpri_dma_eth client rx completion
 * callback notifier, ETH to invoke ecpri_dma_eth_rx_poll on hdl to receive
 * packets (potentially multiple times to receive all packets)
 *
 * @user_data: [in] User data provided by ETH to be used when DMA is invokeing
 *             the Rx comp CB
 * @hdl:       [in] Unique connection handler generated by DMA driver to
 *             identify the Tx & Rx endpoints
 */
typedef void (*ecpri_dma_eth_rx_comp_cb)(void *user_data,
					 ecpri_dma_eth_conn_hdl_t hdl);

/**
 * struct ecpri_dma_eth_rx_comp_cb - ecpri_dma_eth client tx completion
 * callback notifier
 *
 * @user_data:          [in]  User data provided by ETH to be used when DMA is
 *                      invokeing the Tx comp CB
 * @hdl:                [in]  Unique connection handler generated by DMA driver
 *                      to identify the Tx & Rx endpoints
 * @comp_pkts:          [in]  Array of packets DMA completed handling.
 *                      ETH to copy completion data locally as DMA shall free
 *                      this memory upon CB function return.
 * @num_of_completed:   [in] Array size.
 */
typedef void (*ecpri_dma_eth_tx_comp_cb)(
	void *user_data, ecpri_dma_eth_conn_hdl_t hdl,
	struct ecpri_dma_pkt_completion_wrapper **comp_pkts,
	u32 num_of_completed);

/**
 * struct ecpri_dma_eth_register_params - DMA readiness parameters
 *
 * @notify_ready:   ecpri_dma_eth client ready callback notifier
 * @userdata_ready: userdata for ecpri_dma_eth ready cb
 * @notify_rx_comp: ecpri_dma_eth client rx completion callback notifier
 * @userdata_rx:    userdata for ecpri_dma_eth rx cb
 * @notify_tx_comp: ecpri_dma_eth client tx completion callback notifier
 * @userdata_tx:    userdata for ecpri_dma_eth tx cb
 */
struct ecpri_dma_eth_register_params {
	ecpri_dma_ready_cb notify_ready;
	void *userdata_ready;
	ecpri_dma_eth_rx_comp_cb notify_rx_comp;
	void *userdata_rx;
	ecpri_dma_eth_tx_comp_cb notify_tx_comp;
	void *userdata_tx;
};

/**
 * struct ecpri_dma_eth_endpoint_connect_params - DMA connection parameters
 *
 * @link_index: Link index of the endpoints to connect
 * @tx_ring_length: ETH driver to provide Tx descriptor ring length
 * @rx_ring_length: ETH driver to provide Rx descriptor ring size
 * @p_type: Port type of the endpoints to connect
 * @tx_mod_cfg: Moderation configurations of the Tx endpoint to connect
*/
struct ecpri_dma_eth_endpoint_connect_params {
	u32 link_index;
	u32 tx_ring_length;
	u32 rx_ring_length;
	enum ecpri_dma_endp_stream_dest p_type;
	struct ecpri_dma_moderation_config tx_mod_cfg;
};

/**
 * struct ecpri_dma_connection_stats_rx - DMA connection statistics for Rx
 * endpoint
 *
 * TBD
*/
struct ecpri_dma_connection_stats_rx {
	/* TBD */
};

/**
 * struct ecpri_dma_connection_stats_tx - DMA connection statistics for Tx
 * endpoint
 *
 * TBD
*/
struct ecpri_dma_connection_stats_tx {
	/* TBD */
};

/**
 * struct ecpri_dma_connection_stats - DMA connection statistics
 *
 * @rx_stats: Rx endpoint statistics
 * @tx_stats: Tx endpoint statistics
*/
struct ecpri_dma_connection_stats {
	struct ecpri_dma_connection_stats_rx rx_stats;
	struct ecpri_dma_connection_stats_tx tx_stats;
};

/**
 * struct ecpri_dma_eth_ops - Structure to contain DMA driver API functions
*/
struct ecpri_dma_eth_ops {
	int (*ecpri_dma_eth_register)(
		struct ecpri_dma_eth_register_params *ready_info,
		bool *is_dma_ready);
	void (*ecpri_dma_eth_deregister)(void);
	int (*ecpri_dma_eth_connect_endpoints)(
		struct ecpri_dma_eth_endpoint_connect_params *params,
		ecpri_dma_eth_conn_hdl_t *hdl);
	int (*ecpri_dma_eth_disconnect_endpoints)(ecpri_dma_eth_conn_hdl_t hdl);
	int (*ecpri_dma_eth_start_endpoints)(ecpri_dma_eth_conn_hdl_t hdl);
	int (*ecpri_dma_eth_stop_endpoints)(ecpri_dma_eth_conn_hdl_t hdl);
	int (*ecpri_dma_eth_transmit)(ecpri_dma_eth_conn_hdl_t hdl,
				      struct ecpri_dma_pkt **pkts,
				      u32 num_of_pkts, bool commit);
	int (*ecpri_dma_eth_commit)(ecpri_dma_eth_conn_hdl_t hdl);
	int (*ecpri_dma_eth_tx_ring_state)(ecpri_dma_eth_conn_hdl_t hdl,
					   u32 *available);
	int (*ecpri_dma_eth_rx_ring_state)(ecpri_dma_eth_conn_hdl_t hdl,
					   u32 *available);
	int (*ecpri_dma_eth_rx_mode_set)(ecpri_dma_eth_conn_hdl_t hdl,
					 enum ecpri_dma_notify_mode mode);
	int (*ecpri_dma_eth_rx_mode_get)(ecpri_dma_eth_conn_hdl_t hdl,
					 enum ecpri_dma_notify_mode *mode);
	int (*ecpri_dma_eth_rx_poll)(
		ecpri_dma_eth_conn_hdl_t hdl, u32 budget,
		struct ecpri_dma_pkt_completion_wrapper **pkts,
		u32 *actual_num);
	int (*ecpri_dma_eth_replenish_buffers)(ecpri_dma_eth_conn_hdl_t hdl,
					       struct ecpri_dma_pkt **pkts,
					       u32 num_of_pkts, bool commit);
	int (*ecpri_dma_eth_query_stats)(
		ecpri_dma_eth_conn_hdl_t hdl,
		struct ecpri_dma_connection_stats *stats);
};

/* Architecture API functions */

/**
 * ecpri_dma_eth_register() - ETH driver registration with DMA driver
 * @ready_info:	[in] ready_info struct with pointers to ETH CB functions
 * @is_dma_ready: [out] true - if ecpri_dma_eth client is already ready
 *
 * ETH driver registration with DMA driver.
 * ETH to provide DMA with callback functions and DMA to initialize its ETH
 * context and register the CBs provided by ETH.
 * In case DMA is ready the ready call back will not be invoked and
 * is_dma_ready will return true.
 * In case DMA is not ready is_dma_ready will return false and DMA will use the
 * notify_ready CB to notify ETH when it becomes ready.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_register(struct ecpri_dma_eth_register_params *ready_info,
			   bool *is_dma_ready);

/**
 * ecpri_dma_eth_deregister() - ETH driver remove registeration with DMA driver
 */
void ecpri_dma_eth_deregister(void);

/**
 * ecpri_dma_eth_connect_endpoints() - ETH driver initialize specific endpoints
 * with DMA driver
 * @params: [in] Connection identifer parameters and configurations
 * @hdl:    [out] Unique connection handler generated by DMA driver to identify
 *          the Tx & Rx endpoints
 *
 * ETH driver initialize specific endpoints with DMA driver.
 * DMA will initialize and configure the matching endpoints driver context and
 * hw context.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_connect_endpoints(
	struct ecpri_dma_eth_endpoint_connect_params *params,
	ecpri_dma_eth_conn_hdl_t *hdl);

/**
 * ecpri_dma_eth_disconnect_endpoints() - ETH driver remove specific endpoints
 * with DMA driver
 * @hdl:    [in] Unique connection handler generated by DMA driver to identify
 *          the Tx & Rx endpoints
 *
 * DMA will destroy and remove the matching endpoints driver context and hw
 * context.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_disconnect_endpoints(ecpri_dma_eth_conn_hdl_t hdl);

/**
 * ecpri_dma_eth_start_endpoints() - ETH driver start specific endpoints with
 * DMA driver
 * @hdl:    [in] Unique connection handler generated by DMA driver to identify
 * the Tx & Rx endpoints
 *
 * DMA will start the matching endpoints.
 * Pipe may be started after ecpri_dma_eth_connect_endpoints or (restarted)
 * after ecpri_dma_eth_stop_endpoints.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_start_endpoints(ecpri_dma_eth_conn_hdl_t hdl);

/**
 * ecpri_dma_eth_stop_endpoints() - ETH driver stop specific endpoints with DMA
 * driver
 * @hdl:    [in] Unique connection handler generated by DMA driver to identify
 * the Tx & Rx endpoints
 *
 * DMA will stop the matching endpoints.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_stop_endpoints(ecpri_dma_eth_conn_hdl_t hdl);

/**
 * ecpri_dma_eth_transmit() - ETH driver to enqueue packets on a specific Tx
 * endpoint with DMA driver
 * @hdl:            [in] Unique connection handler generated by DMA driver to
 *                  identify the Tx & Rx endpoints
 * @pkts:			[in] Array of packets to transmit via DMA
 * @num_of_pkts:    [in] Array size
 * @commit:         [in] true to ring the DB once all packets are on the ring
 *
 * DMA will enqueue all packets in the pkts array on the the matching Tx
 * endpoint ring.
 * DMA will handle chaining of fragmented packets.
 * DMA will ring the DB only if commit is set to true.
 *
 * ETH to not release the packets and SKBs until completion nofication is
 * received from DMA.
 * Limitation: ETH driver shall verify ring has enough space in it for all
 * packet fragments before transmit.
 * Function is BLOCKING until all fragments are placed on the ring.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_transmit(ecpri_dma_eth_conn_hdl_t hdl,
			   struct ecpri_dma_pkt **pkts, u32 num_of_pkts,
			   bool commit);

/**
 * ecpri_dma_eth_commit() - ETH driver commit packets on a specific Tx endpoint
 * @hdl:    [in] Unique connection handler generated by DMA driver to identify
 *          the Tx & Rx endpoints
 *
 * DMA will ring the Tx endpoint DB on the last enqueued element in the Tx
 * endpoint ring.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_commit(ecpri_dma_eth_conn_hdl_t hdl);

/**
 * ecpri_dma_eth_tx_ring_state() - ETH driver to query number of available
 * elements on Tx endpoint ring
 * @hdl:        [in] Unique connection handler generated by DMA driver to
 *              identify the Tx & Rx endpoints
 * @available:  [out] Number of available elements in the ring.
 *
 * DMA will return the number of available elements on the Tx endpoint ring.
 * Elements are buffers, a packet may be fragmented into several buffers.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_tx_ring_state(ecpri_dma_eth_conn_hdl_t hdl, u32 *available);

/**
 * ecpri_dma_eth_rx_ring_state() - ETH driver to query number of available
 * elements on Rx endpoint ring
 * @hdl:        [in] Unique connection handler generated by DMA driver to
 *              identify the Tx & Rx endpoints
 * @available:  [out] Number of available elements in the ring.
 *
 * DMA will return the number of available elements on the Rx endpoint ring.
 * Elements are buffers, a packet may be fragmented into several buffers.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_rx_ring_state(ecpri_dma_eth_conn_hdl_t hdl, u32 *available);

/**
 * ecpri_dma_eth_rx_mode_set() - ETH driver to set mode of Rx ring
 * @hdl:    [in] Unique connection handler generated by DMA driver to identify
 *          the Tx & Rx endpoints
 * @mode:   [in] New mode to set the Rx endpoint
 *
 * DMA will change the mode of the matching Rx endpoint according to the input
 * param.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_rx_mode_set(ecpri_dma_eth_conn_hdl_t hdl,
			      enum ecpri_dma_notify_mode mode);

/**
 * ecpri_dma_eth_rx_mode_get() - DMA driver to provide mode of Rx ring
 * @hdl:    [in] Unique connection handler generated by DMA driver to identify
 *          the Tx & Rx endpoints
 * @mode:   [out] Current mode to set the Rx endpoint
 *
 * DMA provide the mode of the matching Rx endpoint.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_rx_mode_get(ecpri_dma_eth_conn_hdl_t hdl,
			      enum ecpri_dma_notify_mode *mode);

/**
 * ecpri_dma_eth_rx_poll() - ETH driver to poll packets received on a specific
 * Rx endpoint with DMA driver
 * @hdl:		[in] Unique connection handler generated by DMA driver to
 *              identify the Tx & Rx endpoints
 * @budget:		[in] Number of packets to poll
 * @pkts:		[out] Array of packet recived on the specific Rx endpoint via
 *              the DMA.
 * @actual_num: [out] actual number of packets which were polled, may be less
 *              or equal to budget
 *
 * DMA shall provide packets which were received on the matching Rx endpoint to
 * the ETH driver up to the
 * provided budget.
 * Each element in the pkts array is a single buffer in a packet received.
 * ETH to check comp_code field for EOT (End of Transmit) to indicate packet
 * limits.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_rx_poll(ecpri_dma_eth_conn_hdl_t hdl, u32 budget,
			  struct ecpri_dma_pkt_completion_wrapper **pkts,
			  u32 *actual_num);

/**
 * ecpri_dma_eth_replenish_buffers() - ETH driver to enqueue empty buffers on a
 * specific Rx endpoint with DMA driver
 * @hdl:            [in] Unique connection handler generated by DMA driver to
 *                  identify the Tx & Rx endpoints
 * @pkts:           [in] Array of buffers to enqueue to the DMA ring
 * @num_of_pkts:    [in] Array size
 * @commit:         [in] true to ring the DB once all buffers are on the ring
 *
 * DMA will enqueue all buffers in the pkts array on the the matching Rx
 * endpoint ring.
 * DMA will ring the DB only if commit is set to true.
 *
 * ETH to not release the buffers until completion nofication is received from
 * DMA.
 * Function is BLOCKING until all buffers are placed on the ring.
 * Limitation: ETH driver shall verify ring has enough space in it for all
 * buffers before transmit.
 * Limitation: Each element in pkts array to have exactly one buffer.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_replenish_buffers(ecpri_dma_eth_conn_hdl_t hdl,
				    struct ecpri_dma_pkt **pkts,
				    u32 num_of_pkts, bool commit);

/**
 * ecpri_dma_eth_query_stats() - ETH driver to query statistics on a specific
 * connection with DMA driver
 * @hdl:    [in] Unique connection handler generated by DMA driver to identify
 *          the Tx & Rx endpoints
 * @stats:  [out] Structure of the statistics collected on the specified
 *          connection
 *
 * DMA will provide all collected statistics on the provided connection.
 *
 * Returns:	0 on success, negative on failure
 */
int ecpri_dma_eth_query_stats(ecpri_dma_eth_conn_hdl_t hdl,
			      struct ecpri_dma_connection_stats *stats);

#endif //_ECPRI_DMA_ETH_H_